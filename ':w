extern crate termion;

// Set up termion
use std::io::{self, stdin, stdout, Stdout, Write};
use termion::cursor;
use termion::event::Key;
use termion::input::TermRead;
use termion::raw::{IntoRawMode, RawTerminal};

struct GridPosition {
    x_position: u16,
    y_position: u16,
}

fn set_field(stdout: &mut RawTerminal<std::io::Stdout>) {
    let side_length: usize = 20;
    let choice: u16;
    let stdin = stdin();
    let mut generation: u16 = 1;
    let mut highlight_position = GridPosition {
        x_position: 0,
        y_position: 0,
    };

    let mut grid: Vec<Vec<bool>> = vec![vec![false; side_length]; side_length];

    loop {
        for (x, row) in grid.iter().enumerate() {
            for (y, &cell) in row.iter().enumerate() {
                let c = if cell { '#' } else { ' ' };
                write!(stdout, "{}", cursor::Goto(x as u16 + 1, y as u16 + 1)).unwrap();
                if x as u16 == highlight_position.x_position
                    && y as u16 == highlight_position.y_position
                {
                    write!(
                        stdout,
                        "{}{}{}",
                        termion::style::Invert,
                        c,
                        termion::style::Reset
                    )
                    .unwrap();
                }
            }
        }

        for choice in stdin.keys() {}
    }
}

fn print_grid(stdout: &mut RawTerminal<std::io::Stdout>, grid: &Vec<Vec<bool>>) {
    for (y, row) in grid.iter().enumerate() {
        for (x, &cell) in row.iter().enumerate() {
            let c = if cell { '#' } else { ' ' };
            write!(stdout, "{}{}", cursor::Goto(x as u16 + 1, y as u16 + 1), c).unwrap();
        }
    }
}

fn move_cursor_to(
    stdout: &mut RawTerminal<std::io::Stdout>,
    grid: &Vec<Vec<bool>>,
    cursor_y: u16,
    cursor_x: u16,
) {
    for (y, row) in grid.iter().enumerate() {
        for (x, &cell) in row.iter().enumerate() {
            let c = if cell { '#' } else { ' ' };
            write!(stdout, "{}", cursor::Goto(x as u16 + 1, y as u16 + 1)).unwrap();
            if x as u16 == cursor_x && y as u16 == cursor_y {
                write!(
                    stdout,
                    "{}{}{}",
                    termion::style::Invert,
                    c,
                    termion::style::Reset
                )
                .unwrap();
            } else {
                write!(stdout, "{}", c).unwrap();
            }
        }
    }
}

fn num_neighbors(grid: &[Vec<bool>], cell_col: usize, cell_row: usize) -> u16 {
    let mut number_of_neighbors = 0;
    let rows = grid.len();
    let cols = grid[0].len();

    for i in 0..3 {
        for j in 0..3 {
            let x = cell_row as isize + i as isize - 1;
            let y = cell_col as isize + j as isize - 1;

            // skip the cell at 0, 0; skip if x and y are Out of Bounds.
            if i == 1 && j == 1 || x < 0 || y < 0 || x >= rows as isize || y >= cols as isize {
                continue;
            }

            // if the cell at the grid is true, increment number_of_neighbors
            if grid[y as usize][x as usize] {
                number_of_neighbors += 1;
            }
        }
    }
    number_of_neighbors
}

fn set_grid(stdout: &mut RawTerminal<std::io::Stdout>) -> Vec<Vec<bool>> {
    let stdin = stdin();
    let grid: Vec<Vec<bool>> = vec![vec![false; 20]; 20];
    let mut cursor = GridPosition {
        x_position: 0,
        y_position: 0,
    };

    for c in stdin.keys() {
        // Print the grid with the cursor
        move_cursor_to(stdout, &grid, 0, 0);

        // Flush the output
        stdout.flush().unwrap();

        // Handle key input
        match c.unwrap() {
            Key::Up => {
                cursor.y_position -= 1;
            }
            Key::Down => {
                cursor.y_position += 1;
            }
            Key::Right => {
                cursor.x_position -= 1;
            }
            Key::Left => {
                cursor.x_position += 1;
            }
            Key::Char(' ') => {
                // toggle selected cell to true/false
            }

            _ => {}
        }
        // break when user hits enter
    }
    grid
}

fn main() {
    let mut stdout = stdout().into_raw_mode().unwrap();
    let mut generations = 0;
    let mut grid = set_grid(&mut stdout);
    let mut next_field_state: Vec<Vec<bool>> = vec![vec![false; 20]; 20];

    loop {
        if generations > 20 {
            break;
        }
        generations += 1;

        print_grid(&mut stdout, &grid);

        // Apply the rules
        for (x, row) in grid.iter().enumerate() {
            for (y, &_cell) in row.iter().enumerate() {
                let number_of_neighbors: u16 = num_neighbors(&grid, y, x);

                if grid[y][x] && (number_of_neighbors == 2 || number_of_neighbors == 3) {
                    next_field_state[y][x] = true;
                } else if !grid[y][x] && (number_of_neighbors == 3) {
                    next_field_state[y][x] = true;
                } else {
                    next_field_state[y][x] = false;
                }
            }
        }

        // update the current state to the next generation.
        for (x, row) in grid.iter_mut().enumerate() {
            for (y, cell) in row.iter_mut().enumerate() {
                *cell = next_field_state[y][x];
            }
        }
        stdout.flush().unwrap();
    }
}

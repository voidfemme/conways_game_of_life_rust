extern crate termion;

// Set up termion
use std::io::{self, stdin, stdout, Write};
use std::thread;
use std::time::Duration;
use termion::cursor;
use termion::raw::IntoRawMode;
use termion::screen::AlternateScreen; // separate screen buffer to write to a separate screen
                                      // buffer without messing up the user's terminal.

struct MenuOptions<'a> {
    number_of_options: usize,
    menu_options: Vec<&'a str>, // `'a` is implicitly the entire current scope in which the
                                // variable is instantiated.
}

fn main() {
    let stdout = stdout().into_raw_mode().unwrap();
    let stdin = stdin();

    let main_menu = MenuOptions {
        number_of_options: 4,
        menu_options: vec![
            "Welcome to the game of Life!",
            "1. Start game",
            "2. Set game settings",
            "3. Quit Game",
        ],
    };

    let mut choice: i32;
    let mut highlight_position: usize;
    loop {
        print_menu(&main_menu, highlight_position);
    }
}

fn prompt_user(prompt: &str) -> String {
    print!("{}", &prompt);
    io::stdout().flush().unwrap();

    let mut user_input = String::new();
    io::stdin()
        .read_line(&mut user_input)
        .expect("Failed to read line");
    user_input = user_input.trim_end().to_string(); // This line creates a copy of `user_input`
    user_input
}

fn print_menu(menu: &MenuOptions, highlight_position: usize) {
    // Display menu, and use highlight_position to highlight the currently selected menu item.
    for (i, option) in menu.menu_options.iter().enumerate() {
        if i == highlight_position {
            println!("> {}", option);
        } else {
            println!("  {}", option);
        }
    }
}
